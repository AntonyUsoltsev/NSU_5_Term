# 1. Задачи на работу с потоками.
**Блок задач на “удовлетворclительно”**

    1.1. Создание потоков посредством POSIX API:
        a. Склонируйте репозиторий git@github.com:mrutman/os.git. Изучите и запустите
            программу threads/thread.c. Добейтесь чтобы гарантированно выполнялись оба
            потока. 
        b. Измените программу, добавив создание 5-ти потоков с одинаковой поточной
            функцией.
        c. В поточной функции распечатайте:
            i. идентификаторы процесса, родительского процесса, потока. Для
                получения идентификатора потока используйте функции pthread_self() и
                gettid(). Сравните с тем что функция pthread_create() вернула через
                первый аргумент. Объясните результат. Почему для сравнения
                идентификаторов POSIX потоков надо использовать функцию
                pthread_equal()?
            ii. адреса локальной, локальной статической, локальной константной и
                глобальной переменных. Объясните результат.
        d. В поточной функции попробуйте изменить локальную и глобальную
            переменные. Видны ли изменения из других потоков? Объясните результат.
        e. Изучите /proc/pid/maps для полученного процесса. Найдите в нем стеки потоков.
        f. Запустите программу из-под strace. Найдите системные вызовы, которые
            создали ваши потоки.

    1.2. Потоки Joinable and Detached.
        a. Напишите программу, в которой основной поток будет дожидаться завершения
            созданного потока.
        b. Измените программу так чтобы созданный поток возвращал число 42, а
            основной поток получал это число и распечатывал.
        c. Измените программу так чтобы созданный поток возвращал указатель на строку
            “hello world”, а основной поток получал этот указатель и распечатывал строку.
        d. Напишите программу, которая в бесконечном цикле будет создавать поток, с
            поточной функцией, которая выводит на свой идентификатор потока и
            завершается. Запустите. Объясните результат.
        e. Добавьте вызов pthread_detach() в поточную функцию. Объясните результат.
        f. Вместо вызова pthread_detach() передайте в pthread_create() аргументы,
            задающие тип потока - DETACHED. Запустите, убедитесь что поведение не
            изменилось.

    1.3. Передача параметров в поточную функцию.
        a. Создайте структуру с полями типа int и char*. Создайте экземпляр, этой
            структуры и проинициализируйте. Создайте поток и передайте указатель на эту
            структуру в качестве параметра. В поточной функции распечатайте содержимое
            структуры.
        b. Измените программу так чтобы поток создавался как detached поток. Объясните
            в какой области памяти нужно располагать структуру в этом случае.

    1.4 Прерывание потока.
        a. Напишите программу, в которой поточная функция в бесконечном цикле
            распечатывает строки. Используйте pthread_cancel() для того чтобы ее
            остановить.
        b. Измените программу так чтобы поточная функция ничего не распечатывала, а в
            бесконечном цикле увеличивала счетчик на 1. Используйте pthread_cancel() для
            того чтобы ее остановить. Объясните результат. Что можно сделать, чтобы
            pthread_cancel() прервал поток?
        c. В поточной функции выделите память под строку “hello world” с помощью
            malloc(). Распечатывайте в бесконечном цикле полученную строку. Используйте
            pthread_cancel() для того чтобы прервать поточную функцию. Добейтесь чтобы 
            по завершению память, выделенная под строку освобождалась. Используйте
            pthread_cleanup_push/pop().

    1.5. Обработка сигналов в многопоточной программе.
        a. Напишите программу с тремя потоками, такими что: первый поток блокирует
            получения всех сигналов, второй принимает сигнал SIGINT при помощи
            обработчика сигнала, а третий - сигнал SIGQUIT при помощи функции
            sigwait().
        b. Можно ли установить обработчики сигнала для каждого потока?


**Блок задач на “хорошо”**

    1.6. Разработать собственную функцию для создания ядерных потоков - аналог
        pthread_create():
        int mythread_create(mythread_t thread, void *(start_routine), void *arg);
        Функция должна возвращать успех-неуспех.

**Блок задач на “отлично”**

    1.7. Разработать собственную функцию для создания пользовательских потоков:
        int uthread_create(uthread_t thread, void *(start_routine), void *arg);
        Функция должна возвращать успех-неуспех.
        Допускается реализация без вытеснения потока.
